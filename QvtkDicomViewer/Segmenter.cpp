#include "Segmenter.h"
#include <vtkDICOMImageReader.h>

/*
 * 默认构造
 */
Segmenter::Segmenter(QWidget *parent)
	: QWidget(parent)
{
	ui.setupUi(this);
}
/*
 * 带参数构造
 */
Segmenter::Segmenter(std::string Filename, QWidget* parent) : QWidget(parent)
{
	ui.setupUi(this);
	m_Filename = Filename;
	m_segment_fun = NULL_Seg;
	//监控当前所选的算法的变化
	connect(this, SIGNAL(SegmentFuncChange()), this, SLOT(OnSegmentFuncChange()));
}
/*
 * 析构,处理掉所有的非智能指针对象
 */
Segmenter::~Segmenter()
{
}

void Segmenter::closeEvent(QCloseEvent *event)
{
	//renderWindowInteractor->EndPanEvent();
	//renderWindowInteractor->ExitEvent();
	//renderWindowInteractor->EndPickCallback();
	renderWindowInteractor->ExitCallback();
}
/*
 *联通阈值方法
 */
void Segmenter::OnConnectedThreshold()
{
	m_segment_fun = Seg_connectedthres;
	emit SegmentFuncChange();
}

/*
 *分水岭
 */
void Segmenter::OnWatershedThreshold()
{
	m_segment_fun = Seg_waterseg;
	emit SegmentFuncChange();
}
/*
 *邻域连接法
 */
void Segmenter::OnNeighborhoodConnected()
{
	m_segment_fun = Seg_neighconnected;
	emit SegmentFuncChange();
}
/*
 * 置信连接法
 */
void Segmenter::OnConfidenceConnected()
{
	m_segment_fun = Seg_confidconnected;
	emit SegmentFuncChange();
}
/*
 * 快速匹配
 */
void Segmenter::OnFastMarching()
{
	m_segment_fun = Seg_fastmarching;
	emit SegmentFuncChange();
}
/*
 * 形状检测
 */
void Segmenter::OnShapeDetection()
{
	m_segment_fun = Seg_shapedectection;
	emit SegmentFuncChange();
}
/*
 * 响应分割方法的变化/首次设置
 * 
 * 我觉得这里面可以拆开成两部分,一部分一次性的初始化代码放在这个类的构造上,另一部分每次换算法都用执行的放这里
 */
void Segmenter::OnSegmentFuncChange()
{
	// Read the image
	vtkSmartPointer<vtkDICOMImageReader> reader = vtkSmartPointer<vtkDICOMImageReader>::New();
	if (m_Filename=="")
	{
		//提示一下:但是这个问题实际上是不可能出现的
		return;
	}
	reader->SetFileName(m_Filename.c_str());
	reader->Update();

	vtkSmartPointer<vtkImageViewer2> imageViewer = vtkSmartPointer<vtkImageViewer2>::New();
	imageViewer->SetInputConnection(reader->GetOutputPort());
	//imageViewer->SetGlobalWarningDisplay(0);

	// Picker 
	vtkSmartPointer<vtkPropPicker> propPicker = vtkSmartPointer<vtkPropPicker>::New();
	propPicker->PickFromListOn();
	propPicker->AddPickList(imageViewer->GetImageActor());// Give the picker a prop to pick

	// 显示
	renderWindowInteractor = vtkSmartPointer<vtkRenderWindowInteractor>::New();
	imageViewer->SetInputConnection(reader->GetOutputPort());
	imageViewer->SetupInteractor(renderWindowInteractor);
	imageViewer->SetSize(600, 600);

	vtkRenderer* renderer = imageViewer->GetRenderer();
	renderer->ResetCamera();
	renderer->GradientBackgroundOn();
	renderer->SetBackground(0, 0, 0);//背景颜色
	//renderer->SetBackground2(1, 1, 1);

	// 在画布上叠加 窗宽窗位 鼠标悬停位置 
	vtkSmartPointer<vtkCornerAnnotation> cornerAnnotation = vtkSmartPointer<vtkCornerAnnotation>::New();
	cornerAnnotation->SetLinearFontScaleFactor(2);
	cornerAnnotation->SetNonlinearFontScaleFactor(1);
	cornerAnnotation->SetMaximumFontSize(20);
	cornerAnnotation->SetText(0, "Off Image");
	cornerAnnotation->SetText(3, "<window>\n<level>");
	cornerAnnotation->GetTextProperty()->SetColor(1, 0, 0);

	imageViewer->GetRenderer()->AddViewProp(cornerAnnotation);

	// Callback listens to MouseMoveEvents invoked by the interactor's style
	vtkSmartPointer<vtkImageSegmentCallback> callback = vtkSmartPointer<vtkImageSegmentCallback>::New();//交互回调定义在上面
	callback->SetViewer(imageViewer);
	callback->SetAnnotation(cornerAnnotation);
	callback->SetPicker(propPicker);
	callback->SetQvtk(ui.qvtkWidget_Segment);
	callback->SetCount(m_segment_fun);//注意值的对应=============================>>>>>这里是启动对应的算法的位置
	//callback->SetDir(dir);//这个函数还有用么
	// InteractorStyleImage allows for the following controls:
	// 1) middle mouse + move = camera pan
	// 2) left mouse + move = window/level
	// 3) right mouse + move = camera zoom
	// 4) middle mouse wheel scroll = zoom
	// 5) 'r' = reset window/level
	// 6) shift + 'r' = reset camera
	vtkInteractorStyleImage* imageStyle = imageViewer->GetInteractorStyle();
	ui.qvtkWidget_Segment->SetRenderWindow(imageViewer->GetRenderWindow());

	imageStyle->AddObserver(vtkCommand::MouseMoveEvent, callback);
	imageStyle->AddObserver(vtkCommand::LeftButtonPressEvent, callback);

	renderWindowInteractor->Initialize();
	renderWindowInteractor->Start();
	//reader->Delete();

	//return EXIT_SUCCESS;
}
